# scientia

https://blog.51cto.com/u\_14410880/2548418 https://blog.csdn.net/qq\_42243225/article/details/105833809



一致性hash \
普通hash算法Redis服务器变动时，所有缓存的位置都会发生改变 一致性Hash算法也是使用取模的方法，不过，上述的取模方法是对服务器的数量进行取模，而一致性的Hash算法是对2的32方取模。即，一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为0 \~ 2^32 - 1(一个32位无符号整型) 将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台服务器就确定在了哈希环的一个位置上

B+树与红黑树的区别 \
B+ 树的优点在于：由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。B+树的叶子结点都是相连的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

代理模式、职责链模式 \
责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。

Top命令 \
多核 cpu 为啥只有一个 running 的 task \
单例模式的缺点 \
优点： 1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 3.提供了对唯一实例的受控访问。 4.由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 5.允许可变数目的实例。 6.避免对共享资源的多重占用。\
&#x20;缺点： 1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 3.单例类的职责过重，在一定程度上违背了“单一职责原则”。 4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

aabccb---->a2b1c2b1

http 接口耗时过高排查思路 \
top命令查看当前CPU消耗过高的进程，得到进程id \
根据进程id得到占比较高的线程id 将线程id转换为十六进制 \
根据进程编号用jstack命令查看线程id，可以得到线程的具体堆栈信息

cpu调度算法 \
First Come，First Served(FCFS) \
SJF(Short Job First，短作业优先) \
RR算法(按时间片来轮转调度)

磁盘调度算法 \
先来先服务算法（FCFS） \
最短寻道时间优先算法（SSTF） \
扫描算法（SCAN） \
循环扫描算法（CSCAN）



redis \
redis底层数据结构、set底层用的什么结构、字典底层用的什么结构 \
大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数。\
通过为链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅、慢查询、监视器等方面发挥作用（后面会介绍）。 \
Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用，使用链地址法解决哈希冲突。 \
跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。 \
整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能的节省内存。 \
压缩列表是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。

zset底层数据结构、数据量少的时候用跳表合适么，有什么问题，用什么好

redis是怎么做主从复制的，跟mysql不太一样，区别在哪里 \
从节点开启主从复制，有3种方式：\
1\. 配置文件： 在从服务器的配置文件中加入：slaveof\
2\. 启动命令： redis-server启动命令后加入 --slaveof\
3\. 客户端命令： Redis服务器启动后，直接通过客户端执行命令：slaveof ，则该Redis实例成为从节点。 主从复制过程 1、保存主节点（master）信息。 2、主从建立socket连接 3、发送ping命令 4、权限验证 5、同步数据集 6、命令持续复制

\
数据库： \
解释一下 explain中 using index innodb 为什么用b+树而不用二叉树 \
操作系统一页多大 4kb \
mysql底层会优化最左前缀么？ \
innodb默认的隔离级别解决的是什么问题 \
在RR的隔离级别下，Innodb使用MVVC和next-key locks解决幻读，MVCC解决的是普通读（快照读）的幻读，next-key locks解决的是当前读情况下的幻读。

读未提交、读已提交、可重复读、串行化 MVCC https://www.cnblogs.com/sunsky303/p/14205861.html \
InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的。一个保存了行的事务ID（DB\_TRX\_ID），一个保存了行的回滚指针（DB\_ROLL\_PT） Read View

\
计算机网络 \
四次挥手为啥比三次握手多一次，第二次就不能一起发么？ \
server端有可能数据未传输完成，一起发直接关闭连接会导致异常

三次握手 \
第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN\_SENT状态，等待Server确认。\
第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN\_RCVD状态。 \
第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 \
四次挥手 \
第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN\_WAIT\_1状态。 \
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE\_WAIT状态。 \
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST\_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME\_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1， Server进入CLOSED状态，完成四次挥手。

\
java \
hashmap是怎么监测到多线程的put的 \
hashmap非扩容期间多线程存在什么问题 \
hashmap fail-fast机制 \
在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map cas 自旋锁&#x20;

怎么自己做一个starter\
创建名字为 xxx-spring-boot-starter 的启动器项目。\
创建名字为 xxx-spring-boot-autoconfigure的项目。 编写属性绑定类 xxxProperties. 编写服务类，引入 xxxProperties. 编写自动配置类XXXAutoConfiguration注入配置。 创建 spring.factories 文件，用于指定要自动配置的类。\
启动器项目为空项目，用来引入 xxx-spring-boot-autoconfigure等其他依赖。\
项目引入 starter，配置需要配置的信息。



ks&#x20;

jvm内存结构 \
JVM 的运行时数据区主要包括：堆、栈、方法区、程序计数器&#x20;

oom异常什么时候出现

threadlocal使用场景 \
在进行对象跨层传递的时候，可以考虑ThreadLocal，避免方法多次传递，打破层次间的约束 线程间数据隔离 进行事务操作，用于储存线程事务信息。

gc问题如何排查 \
jstat -gcutil -t pid 1000 1000查看GC日志 \
jmap -heap pid查看堆内存情况 \
jmap -hsito pid查看哪些类占用的空间多 \
jmap -dump:format=b,file=xxxx.hprof Dump堆内存日志，通过MAT内存分析工具分析日志

java进程还在，但是无响应的排查思路 \
服务请求无响应，使用top，确认Java进程存在，且相关进程CPU占用率保持稳定。 \
使用jstat，查看young GC次数，若在有业务请求的情况下保持不变，没有增加，确认垃圾回收器停止工作。 \
使用jstack，打印Java进程堆栈信息，确认大部分业务进程处于Block状态，进程处于假死状态。 \
查看线程日志，分析原因。

垃圾回收算法、垃圾回收器、怎么判断对象不可达\
引用计数法\
可达性分析算法(虚拟机栈、方法区的类属性所引用的对象、方法区中常量所引用的对象、本地方法栈中引用的对象)

双亲委派机制，优点；什么时候要破坏双亲委派机制，怎么破坏 \
类加载器按照层级分为： 根加载器（BootStrap，负责加载\<JAVA\_HOME>/lib目录下的文件） 扩展类加载器（ExtClassLoader，负责加载\<JAVA\_HOME>/lib/ext目录下的文件） 系统类加载器（AppClassLoader，负责加载classpath目录下的文件） \
使用双亲委派的好处： 使用双亲委派机制加载类的好处就是可以提高系统的安全性和稳定性 因为类加载器区分了层级，所以被加载的类也具备了优先级的层次关系，通过划分不同层级类加载器的职责，使得核心类可以被优先加载，确保了程序的稳定性； 由于每个类只能被加载一次，确保了类的全局唯一性，保证了已加载过的API核心类不会被篡改； 在加载核心类库时，如果需要使用用户代码，双亲委派流程就无法满足。 \
怎么破坏双亲委派： JDK提供了SPI机制（服务发现机制），DriverManager就是使用SPI破坏的双亲委派，在加载DriverManager的时候会执行静态代码块中的loadInitialDrivers（）方法，该方法内部会通过ServiceLoader.load(Driver.class)，获取上下文类加载器，然后加载第三方jar包里面，META-INF/services目录下所有Driver的实现类 \
优点：解耦，使得我们可以面向接口编程，无需硬编码的方式即可引入实现类 \
缺点：不能按需加载，加载实现类时，会将配置文件中接口的实现类全部实例化一遍，如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，会浪费时间和空间

lock锁原理，aqs同步队列 \
reentrantLock怎么实现公平锁

自旋锁比重量级锁的优点 \
https://www.cnblogs.com/wade-luffy/p/5969418.html?ivk\_sa=1024320u \
线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。同时我们可以发现，很多对象锁的锁定状态只会持续很短的一段时间，例如整数的自加操作，在很短的时间内阻塞并唤醒线程显然不值得，为此引入了自旋锁。 \
自旋锁省去了阻塞锁的时间空间（队列的维护等）开销

反射的原理及优点，aop怎么使用反射 \
反射可以让程序在运行时具有检测自己和获取当前运行环境的能力。 增强程序灵活性和可拓展性，可帮助程序进行解耦合，提高自身的适应能力 \
缺点：性能问题、安全限制、程序健壮性

为什么要用自增主键作为索引，好处是什么 \
如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 总的来说就是可以提高查询和插入的性能。

什么是InnoDB的写缓冲？ \
InnoDB使用了一种叫做doublewrite的特殊文件flush技术，在把pages写到date files之前，InnoDB先把它们写到一个叫doublewrite buffer的连续区域内，在写doublewrite buffer完成后，InnoDB才会把pages写到data file的适当的位置 \
InnoDB的page size一般是16KB，其数据校验也是针对这16KB来计算的，将数据写入到磁盘是以page为单位进行操作的。操作系统写文件是以4KB作为单位的，那么每写一个InnoDB的page到磁盘上，操作系统需要写4个块。而计算机硬件和操作系统，在极端情况下（比如断电）往往并不能保证这一操作的原子性，造成partial page write（部分页写入）问题 \
MySQL写数据page时，会写两遍到磁盘上，第一遍是写到doublewrite buffer，第二遍是从doublewrite buffer写到真正的数据文件中。 \
位于共享表空间上的doublewrite buffer实际上也是一个文件，写共享表空间会导致系统有更多的fsync操作, 而硬盘的fsync性能因素会降低MySQL的整体性能

mysql索引调优常用方法 \
慢日志查询 \
使用缓存减少数据库负载的压力 \
当只需要一条数据时使用LIMIT 1 \
避免全表查询 \
为每张表设置一个id作为其主键 \
尽可能的使用not null \
选择正确的存储引擎 \
为搜索的字段建立索引

第三方jar包与项目中包含同名类是会有警告提示，但是还是可以创建的，但是项目中加载的类是不确定的

kafka rebalance机制 \
Rebalance 本质上是一种协议，规定了一个 Consumer Group 下的所有 consumer 如何达成一致，来分配订阅 Topic 的每个分区 \
Rebalance 的触发条件有3个： \
组成员个数发生变化。例如有新的 consumer 实例加入该消费组或者离开组。 \
订阅的 Topic 个数发生变化。 \
订阅 Topic 的分区数发生变化。 \
Rebalance 发生时，Group 下所有 consumer 实例都会协调在一起共同参与，kafka 能够保证尽量达到最公平的分配。但是 Rebalance 过程对 consumer group 会造成比较严重的影响。在 Rebalance 的过程中 consumer group 下的所有消费者实例都会停止工作，等待 Rebalance 过程完成。

微博关注结构设计 \
使用 tid fromuid touid addTime 表结构，但数据量大时分库分表对于关注列表和粉丝列表不友好 \
使用 redis hash存储关注和粉丝两个列表，使用hgetall获取 https://cloud.tencent.com/developer/article/1451238 \
https://www.infoq.cn/article/weibo-relation-service-with-redis https://blog.cydu.net/weidesign/2012/09/09/weibo-counter-service-design-2/

链表反转指定区域、删除链表倒数第n个节点

lb负载均衡的算法 \
metaspace元空间存放什么内容 \
synchronized和lock锁的区别 \
什么是乐观锁，CAS \
接口幂等性怎么设计

kafka怎么保证的消息有序 \
https://xie.infoq.cn/article/c84491a814f99c7b9965732b1



zj \
redis是先删缓存还是先写库 \
先更新数据库，再删缓存 \
删缓存失败导致不一致 \
订阅程序订阅数据库的binlog，另启一段非业务代码获得订阅信息。删除缓存，如果删除失败，将信息发送到消息队列，从队列中获取重试直到成功 \
请求A查询，请求B更新；正好缓存失效，请求A查询数据库得到旧值； \
请求B写入新值并删除缓存之后，请求A才将旧值写入缓存 \
写数据库比读数据库时间更短才可能发生，基本不可能 \
先删缓存，再更新数据库 x \
请求A更新，请求B查询 \
请求A进行写操作，删除缓存； \
请求B查询发现缓存不存在；请求B去数据库查询得到旧值；请求B将旧值写入缓存 \
请求A将新值写入数据库 \
导致数据不一致情况出现，可采用延时双删策略，休眠(读业务耗时+几百ms)时间后再次淘汰缓存 \
先更新数据库，再更新缓存 x \
同时有请求A和B更新，由于网络等原因，B比A更早更新缓存，造成脏数据 \
写数据库场景较多读数据库较少的话，缓存频繁更新浪费性能

面向对象的7大设计原则 \
根据1-5随机数生成方法生成1-7随机数

抢红包系统，30w人同时在线，1w块钱，5-100不等，尽量将钱发完 https://www.zybuluo.com/yulin718/note/93148

cms和G1的区别 \
https://zhuanlan.zhihu.com/p/161204689 \
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现,在标记清理过程中不会导致用户线程无法定位引用对象。仅作用于老年代收集。它的步骤如下： \
初始标记（CMS initial mark）：独占CPU，stop-the-world, 仅标记GCroots能直接关联的对象,速度比较快； \
并发标记（CMS concurrent mark）:可以和用户线程并发执行，通过GCRoots Tracing 标记所有可达对象； \
重新标记（CMS remark）：独占CPU，stop-the-world, 对并发标记阶段用户线程运行产生的垃圾对象进行标记修正,以及更新逃逸对象； \
并发清理（CMS concurrent sweep）：可以和用户线程并发执行，清理在重复标记中被标记为可回收的对象。 \
CMS的优点： \
支持并发收集. \
低停顿,因为CMS可以控制将耗时的两个stop-the-world操作保持与用户线程恰当的时机并发执行，并且能保证在短时间执行完成，这样就达到了近似并发的目的. \
CMS的缺点： \
CMS收集器对CPU资源非常敏感,在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分CPU资源，如果在CPU资源不足的情况下应用会有明显的卡顿。 \
无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。 \
CMS清理后会产生大量的内存碎片，当有不足以提供整块连续的空间给新对象/晋升为老年代对象时又会触发FullGC。且在1.9后将其废除。 \
使用场景 \
它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。&#x20;

G1收集器 \
G1收集器的内存结构完全区别去CMS，弱化了CMS原有的分代模型（分代可以是不连续的空间），将堆内存划分成一个个Region（1MB\~32MB, 默认2048个分区）,这么做的目的是在进行收集时不必在全堆范围内进行。它主要特点在于达到可控的停顿时间，用户可以指定收集操作在多长时间内完成，即G1提供了接近实时的收集特性。它的步骤如下： \
初始标记（Initial Marking）：标记一下GC Roots能直接关联到的对象，伴随着一次普通的Young GC发生，并修改NTAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，此阶段是stop-the-world操作。 根区间扫描，标记所有幸存者区间的对象引用，扫描 Survivor到老年代的引用，该阶段必须在下一次Young GC 发生前结束。 \
并发标记（Concurrent Marking）：是从GC Roots 开始堆中对象进行可达性分析， 找出存活的对象，这阶段耗时较长，但可与用户程序并发执行， 该阶段可以被Young GC中断。 \
最终标记（Final Marking） ：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录， 虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set 中，此阶段是stop-the-world操作，使用snapshot-at-the-beginning (SATB) 算法。 \
筛选回收（Live Data Counting and Evacuation）：首先对各个Region的回收价值和成本进行排序， 根据用户所期望的GC停顿时间来制定回收计划,回收没有存活对象的Region并加入可用Region队列。 这个阶段也可以做到与用户程序一起并发执行， 但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 \
G1的特点 \
并行与并发：G1充分发挥多核性能，使用多CPU来缩短Stop-The-world的时间， \
分代收集：G1能够自己管理不同分代内已创建对象和新对象的收集。 \
空间整合：G1从整体上来看是基于‘标记-整理’算法实现，从局部（相关的两块Region）上来看是基于‘复制’算法实现，这两种算法都不会产生内存空间碎片。 \
可预测的停顿：它可以自定义停顿时间模型，可以指定一段时间内消耗在垃圾回收商的时间不大于预期设定值。 \
使用场景 \
G1 GC切分堆内存为多个区间（Region），从而避免很多GC操作在整个Java堆或者整个年轻代进行。G1 GC只关注你有没有存货对象，都会被回收并放入可用的Region队列。G1 GC是基于Region的GC，适用于大内存机器。即使内存很大，Region扫描，性能还是很高的。 \
CMS收集器和G1收集器的区别 \
区别一： 使用范围不一样 \
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用 \
G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用 \
区别二： STW的时间 \
CMS收集器以最小的停顿时间为目标的收集器。 \
G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型） \
区别三： 垃圾碎片 \
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片 \
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。 \
区别四： 垃圾回收的过程不一样 \
CMS收集器 G1收集器\
初始标记 1.初始标记\
并发标记 2. 并发标记\
重新标记 3. 最终标记\
并发清除 4. 筛选回收

jvm调优 \
https://blog.csdn.net/weixin\_42447959/article/details/81637909 \
这里有几个比较重要的指标： \
内存占用：程序正常运行需要的内存大小。 \
延迟：由于垃圾收集而引起的程序停顿时间。 \
吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值。 \
调优可以依赖参考的数据有系统运行日志、堆栈错误信息、gc日志、线程快照、堆转储快照等 \
GC日志：程序启动时用 -XX:+PrintGCDetails 和 -Xloggc:/data/jvm/gc.log 可以在程序运行时把gc的详细过程记录下来，或者直接配置“-verbose:gc”参数把gc日志打印到控制台 \
用 jps（JVM process Status）可以查看虚拟机启动的所有进程、执行主类的全名、JVM启动参数 \
用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息（各个区的容量、使用容量、gc时间等信息） 用jmap（Memory Map for Java）查看堆内存信息 可以打印出当前堆中所有每个类的实例数量和内存占用。执行 jmap -dump 可以转储堆内存快照到指定文件，然后可以对内存快照进行分析。 \
利用jconsole、jvisualvm分析内存信息(各个区如Eden、Survivor、Old等内存变化情况)

物理内存一定的情况下，新生代设置越大，老年代就越小，Full GC频率就越高，但Full GC时间越短；相反新生代设置越小，老年代就越大，Full GC频率就越低，但每次Full GC消耗的时间越大. \
\-Xms和-Xmx的值设置成相等，堆大小默认为-Xms指定的大小，默认空闲堆内存小于40%时，JVM会扩大堆到-Xmx指定的大小；空闲堆内存大于70%时，JVM会减小堆到-Xms指定的大小。如果在Full GC后满足不了内存需求会动态调整，这个阶段比较耗费资源。 \
新生代尽量设置大一些，让对象在新生代多存活一段时间，每次Minor GC 都要尽可能多的收集垃圾对象，防止或延迟对象进入老年代的机会，以减少应用程序发生Full GC的频率。 \
老年代如果使用CMS收集器，新生代可以不用太大，因为CMS的并行收集速度也很快，收集过程比较耗时的并发标记和并发清除阶段都可以与用户线程并发执行。 \
方法区大小的设置，1.6之前的需要考虑系统运行时动态增加的常量、静态变量等，1.7只要差不多能装下启动时和后期动态加载的类信息就行。 \
代码实现方面，性能出现问题比如程序等待、内存泄漏除了JVM配置可能存在问题，代码实现上也有很大关系： \
避免创建过大的对象及数组：过大的对象或数组在新生代没有足够空间容纳时会直接进入老年代，如果是短命的大对象，会提前出发Full GC。 \
避免同时加载大量数据，如一次从数据库中取出大量数据，或者一次从Excel中读取大量记录，可以分批读取，用完尽快清空引用。 \
当集合中有对象的引用，这些对象使用完之后要尽快把集合中的引用清空，这些无用对象尽快回收避免进入老年代。 \
可以在合适的场景（如实现缓存）采用软引用、弱引用，比如用软引用来为ObjectA分配实例：SoftReference objectA=new SoftReference(); 在发生内存溢出前，会将objectA列入回收范围进行二次回收，如果这次回收还没有足够内存，才会抛出内存溢出的异常。 \
避免产生死循环，产生死循环后，循环体内可能重复产生大量实例，导致内存空间被迅速占满。 \
尽量避免长时间等待外部资源（数据库、网络、设备资源等）的情况，缩小对象的生命周期，避免进入老年代，如果不能及时返回结果可以适当采用异步处理的方式等。

oom怎么定位处理 \
Java服务OOM，最常见的原因为： \
有可能是内存分配确实过小，而正常业务需要使用更大的内存； \
某一个对象被频繁申请，却没有释放，内存不断泄露，导致内存耗尽； \
某一个资源被不断申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接

rpc和http的区别 \
速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿 \
难度来看，RPC实现较为复杂，http相对比较简单 \
灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。

redis主从切换怎么同步数据(跨机房) \
https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html

redis大key会有什么问题 \
单个key 存储的 value 很大 \
hash， set，zset，list 结构中存储过多的元素 \
由于处理这一个KEY时间长，导致服务端发生阻塞 \
对于需要整取 value 的 大 key, 可以尝试将对象分拆成几个 key-value， 使用 multiGet 获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个实例中，降低对单个实例的IO影响; \
对于每次需要取部分 value 的 大 key, 同样可以拆成几个 key-value，也可以将这些存储在一个 hash 中，每个 field 代表具体属性，使用 hget，hmget 来获取部分 value，使用 hset，hmset 来更新部分属性; \
对于 value 中存储过多元素的 key, 同样可以将这部分元素拆分;

rpc dubbo怎么进行的同一个provider通路的请求隔离

怎么实现的限流rateLimit原理 \
漏桶算法的实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃 \
令牌桶算法则是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。桶中存放的令牌数有最大上限，超出之后就被丢弃或者拒绝。当流量或者网络请求到达时，每个请求都要获取一个令牌，如果能够获取到，则直接处理，并且令牌桶删除一个令牌。如果获取不同，该请求就要被限流，要么直接丢弃，要么在缓冲区等待。

java四种引用类型 \
强引用 \
只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了 \
软引用 \
用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。 \
弱引用 \
引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。 \
虚引用 \
是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。虚引用必须要和 ReferenceQueue 引用队列一起使用

rpc的负载均衡怎么做的 \
代理模型 \
客户端并不知道服务端的存在，它所有的请求都打到代理服务，由代理服务去分发到服务端，并且实现公平的负载算法。 \
缺点： 客户端不知道后端的存在，且客户端不可信，此模型还会增加RPC的延迟，而且代理服务会影响服务本身的吞吐量 \
优点： 客户端不需要过多的改造，在中间层做监控等拦截操作非常容易。 \
客户端负载均衡方式(进程内LB（Balancing-aware Client）) \
客户端知道有多个后端服务，由客户端去选择服务端，并且客户端可以从后端服务器中自己总结出一份负载的信息，实现负载均衡算法。 \
优点：高性能，因为消除了第三方的交互 \
缺点：会使客户端的代码大大复杂化：客户端需要跟踪服务器负载和健康情况，维护负载均衡策略，这些策略可能相当复杂。有些时候我们还需要以多种语言实现和维护负载均衡策略，而且客户端需要被信任得是靠谱的客户端

redis服务注册和zookeeper的区别

redis分布式锁和zookeeper分布式锁的区别 \
redis分布式锁怎么续期 \
如何保证消息不丢失

mysql插入一条数据的过程 \
淘宝喵糖怎么设计 \
rocketmq延时消息怎么实现

innodb和myisam区别 \
acid怎么实现的 \
http请求过程 \
三次握手和四次挥手 \
redis数据类型 \
哨兵集群，及怎么选主 \
算法：最多替换一个数字，如果可以变成非递减数组则返回true



tx \
springboot starter原理 \
javaconfig \
redis红锁比setnx的好处 \
设计一个数据流系统（需要用到哪些中间件）

kafka消息队列 \
堆排序 \
ziplist具体实现



mt \
io密集型、cpu密集型核心线程数设置多少 \
redis设计点赞用什么结构 \
高并发抢购 \
怎么定位和解决mysql死锁问题 \
自己设计一种hash算法

cms和g1 \
fullgc的场景 \
redis底层数据结构 \
redis热点key会有什么问题 \
可以在内存中做二级缓存

mysql表数据量大查询会变慢怎么解决 \
mysql索引结构 \
mysql索引失效场景 \
消息队列消息堆积了怎么办 \
合并两个有序的数组

有有效期的红包等怎么设计 \
二级缓存有哪些实现(j2Cache、L2Cache) \
kafka的特性，kafka怎么做到的高可用 \
都有哪些场景会导致消息积压，怎么解决消息积压 \
ACID，数据库怎么做的持久性 \
MVCC怎么解决的幻读



al \
kafka的balance机制和ISR机制 \
删除转义字符’\b’和它前面的字符，如果遇到多个连续的’\b’，则删除相同数量的转义字符和前面的字符。 举例：输入"xabc\b\bd\b\bghi"，期望返回"xghi" \
实现两个线程，使之交替打印1-100,如：两个线程分别为：Printer1和Printer2, \
最后输出结果为： Printer1 — 1 Printer2 一 2 Printer1 一 3 Printer2 一 4

redis单线程为什么可以并发处理多个请求 \
hashmap底层结构，为什么是2的次幂，扩容的时候2的次幂最重要的功能是什么 \
mysql事务的实现 \
BIO NIO在不同场景下性能，BIO高并发时性能消耗在哪

线程oom会影响进程么 \
阻塞队列种类 \
tcp全连接半连接队列 \
aop实现过程 \
g1、cms垃圾回收器比较 \
动态代理生成的类和普通类有什么区别

rocketmq怎么实现顺序消费，事务消息和顺序消费是否可以同时实现

mysql主从复制主服务怎么知道从服务复制成功 \
redis缓存雪崩、缓存击穿、热点数据、滑动窗口 \
缓存穿透 \
查询一个数据库中不存在的数据，每次都会访问DB \
当通过某一个key去查询数据的时候，如果对应在数据库中的数据都不存在，我们将此key对应的value设置为一个默认的值，比如“NULL”，并设置一个缓存的失效时间 \
常见的则是采用布隆过滤器（可以用很小的内存保留很多的数据），将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力 布隆过滤器缺点 \
有误判率，即存在假阳性(False Position)，即不能准确判断元素是否在集合中(补救方法：再建立一个白名单，存储可能会误判的数据) \
不能获取元素本身 \
一般情况下不能从布隆过滤器中删除元素 \
如果采用计数方式删除，可能会存在计数回绕问题

缓存雪崩 \
缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉 \
将系统中key的缓存失效时间均匀地错开，防止统一时间点有大量的key对应的缓存失效 \
重新设计缓存的使用方式，当我们通过key去查询数据时，首先查询缓存，如果此时缓存中查询不到，就通过分布式锁进行加锁，取得锁的进程查DB并设置缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回缓存数据或者再次查询DB

redis中key的过期策略，怎么查询哪些key过期 \
分布式事务tcc

spring中都用到哪些设计模式 \
spring 单例怎么实现的 \
分布式一致性框架 \
怎么实现查找用户当前经纬度1公里范围内的商铺，商铺经纬度应该怎么存储



算法 \
求二叉树的深度 \
去除重复字母 \
leetcode583 两个字符串的删除操作 \
142\. Linked List Cycle II 求有环链表的入口 \
146\. LRU Cache \
124\. Binary Tree Maximum Path Sum 二叉树最大路径和 \
235\. Lowest Common Ancestor of a Binary Search Tree 给定二叉树和两个节点，求这两个节点的最近公共祖先 \
public TreeNode getCommonAncestor(TreeNode root, TreeNode t1, TreeNode t2) { \
&#x20;   if (root == null || t1 == null || t2 == null) return null; \
&#x20;   if (t1 == root || t2 == root) return root; \
&#x20;   TreeNode left = getCommonAncestor(root.left, t1, t2); \
&#x20;   TreeNode right = getCommonAncestor(root.right, t1, t2); \
&#x20;   if (left != null && right != null) return root; \
&#x20;   if (left == null) return right; \
&#x20;   if (right == null) return left; \
}

足球比赛平局次数，篮球比赛平局次数 \
特征循环依赖判定 \[\[0,1],\[1,3],\[3,4],\[0,2],\[2,3]] \
一个数之内有多少对和相等的数 \
数字转中文数字\
A(B(C(,),),E(,)) 转化成二叉树\
给定一棵树前序遍历和中序遍历(无重复元素)，构造二叉树并返回其根节点 \[3,9,20,15,7] \[9,3,15,20,7]

一个n个数的数组，长度k为滑动窗口长度，从0开始滑动，求每次滑动窗口内k个数的最大值 \
二叉树最长路径个数 leetcode 543 \
32G的数据，只有1G内存，如何排序
